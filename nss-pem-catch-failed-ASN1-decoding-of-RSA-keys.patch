From a26144575180f2d3a032ad73ada3ff3793042ffc Mon Sep 17 00:00:00 2001
From: Rob Crittenden <rcritten@redhat.com>
Date: Sun, 24 Jan 2016 19:34:57 +0100
Subject: [PATCH 1/3] catch failed ASN1 decoding of RSA keys

Bug: https://bugzilla.redhat.com/1300652

Upstream-commit: 2bea33ebdd100cd6c24a7a9e5bfbf694de60b655
Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 nss/lib/ckfw/pem/ckpem.h   |  4 +--
 nss/lib/ckfw/pem/pfind.c   |  3 ++-
 nss/lib/ckfw/pem/pobject.c | 63 +++++++++++++++++++++++++++++++++++-----------
 nss/lib/ckfw/pem/prsa.c    | 49 +++++++++++++++++++++++++-----------
 4 files changed, 88 insertions(+), 31 deletions(-)

diff --git a/nss/lib/ckfw/pem/ckpem.h b/nss/lib/ckfw/pem/ckpem.h
index fadfc80..afbe867 100644
--- a/nss/lib/ckfw/pem/ckpem.h
+++ b/nss/lib/ckfw/pem/ckpem.h
@@ -242,8 +242,8 @@ typedef struct pemLOWKEYPrivateKeyStr pemLOWKEYPrivateKey;
  * Fix this when we sync. up with the cleanup work being done at nss-pem project.
  */
 SECStatus ReadDERFromFile(SECItem ***derlist, char *filename, PRBool ascii, int *cipher, char **ivstring, PRBool certsonly);
-const NSSItem * pem_FetchAttribute ( pemInternalObject *io, CK_ATTRIBUTE_TYPE type);
-void pem_PopulateModulusExponent(pemInternalObject *io);
+const NSSItem * pem_FetchAttribute ( pemInternalObject *io, CK_ATTRIBUTE_TYPE type, CK_RV *pError);
+CK_RV pem_PopulateModulusExponent(pemInternalObject *io);
 NSSCKMDObject * pem_CreateObject(NSSCKFWInstance *fwInstance, NSSCKFWSession *fwSession, NSSCKMDToken *mdToken, CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulAttributeCount, CK_RV *pError);
 NSSCKMDSlot *pem_NewSlot( NSSCKFWInstance *fwInstance, CK_RV *pError);
 
diff --git a/nss/lib/ckfw/pem/pfind.c b/nss/lib/ckfw/pem/pfind.c
index 30b1174..088a00e 100644
--- a/nss/lib/ckfw/pem/pfind.c
+++ b/nss/lib/ckfw/pem/pfind.c
@@ -204,8 +204,9 @@ static CK_BBOOL
 pem_attrmatch(CK_ATTRIBUTE_PTR a, pemInternalObject * o) {
     PRBool prb;
     const NSSItem *b;
+    CK_RV error = CKR_OK;
 
-    b = pem_FetchAttribute(o, a->type);
+    b = pem_FetchAttribute(o, a->type, &error);
     if (b == NULL) {
         plog("pem_attrmatch %s %08x: CK_FALSE attr not found\n", pem_attr_name(a->type), a->type);
         return CK_FALSE;
diff --git a/nss/lib/ckfw/pem/pobject.c b/nss/lib/ckfw/pem/pobject.c
index 7e81c2b..ea59c57 100644
--- a/nss/lib/ckfw/pem/pobject.c
+++ b/nss/lib/ckfw/pem/pobject.c
@@ -275,7 +275,8 @@ const NSSItem *
 pem_FetchPrivKeyAttribute
 (
     pemInternalObject * io,
-    CK_ATTRIBUTE_TYPE type
+    CK_ATTRIBUTE_TYPE type,
+    CK_RV * pError
 )
 {
     PRBool isCertType = (pemCert == io->type);
@@ -318,49 +319,73 @@ pem_FetchPrivKeyAttribute
         return &io->u.cert.subject;
     case CKA_MODULUS:
         if (0 == kp->modulus.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_MODULUS\n");
         return &kp->modulus;
     case CKA_PUBLIC_EXPONENT:
         if (0 == kp->modulus.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_PUBLIC_EXPONENT\n");
         return &kp->exponent;
     case CKA_PRIVATE_EXPONENT:
         if (0 == kp->privateExponent.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_PRIVATE_EXPONENT\n");
         return &kp->privateExponent;
     case CKA_PRIME_1:
         if (0 == kp->prime1.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_PRIME_1\n");
         return &kp->prime1;
     case CKA_PRIME_2:
         if (0 == kp->prime2.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_PRIME_2\n");
         return &kp->prime2;
     case CKA_EXPONENT_1:
         if (0 == kp->exponent1.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_EXPONENT_1\n");
         return &kp->exponent1;
     case CKA_EXPONENT_2:
         if (0 == kp->exponent2.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_EXPONENT_2\n");
         return &kp->exponent2;
     case CKA_COEFFICIENT:
         if (0 == kp->coefficient.size) {
-            pem_PopulateModulusExponent(io);
+            *pError = pem_PopulateModulusExponent(io);
+            if (CKR_OK != *pError) {
+                return NULL;
+            }
         }
         plog("  fetch key CKA_COEFFICIENT_2\n");
         return &kp->coefficient;
@@ -523,7 +548,8 @@ const NSSItem *
 pem_FetchAttribute
 (
     pemInternalObject * io,
-    CK_ATTRIBUTE_TYPE type
+    CK_ATTRIBUTE_TYPE type,
+    CK_RV * pError
 )
 {
     CK_ULONG i;
@@ -541,7 +567,7 @@ pem_FetchAttribute
     case CKO_CERTIFICATE:
         return pem_FetchCertAttribute(io, type);
     case CKO_PRIVATE_KEY:
-        return pem_FetchPrivKeyAttribute(io, type);
+        return pem_FetchPrivKeyAttribute(io, type, pError);
     case CKO_NETSCAPE_TRUST:
         return pem_FetchTrustAttribute(io, type);
     case CKO_PUBLIC_KEY:
@@ -836,7 +862,16 @@ pem_mdObject_GetAttributeSize
                                     attribute, pError);
     }
 
-    b = pem_FetchAttribute(io, attribute);
+    b = pem_FetchAttribute(io, attribute, pError);
+    plog("pem_FetchAttribute pError = 0x%08x\n", *pError);
+
+    /* Don't assume that the returned item is NULL on error */
+    if (*pError != CKR_OK) {
+        if ((const NSSItem *) NULL != b) {
+            nss_ZFreeIf(b->data);
+        }
+        return 0;
+    }
 
     if ((const NSSItem *) NULL == b) {
         *pError = CKR_ATTRIBUTE_TYPE_INVALID;
@@ -872,9 +907,9 @@ pem_mdObject_GetAttribute
     }
 
     mdItem.needsFreeing = PR_FALSE;
-    mdItem.item = (NSSItem *) pem_FetchAttribute(io, attribute);
+    mdItem.item = (NSSItem *) pem_FetchAttribute(io, attribute, pError);
 
-    if ((NSSItem *) NULL == mdItem.item) {
+    if ((NSSItem *) NULL == mdItem.item && !*pError) {
         *pError = CKR_ATTRIBUTE_TYPE_INVALID;
     }
 
diff --git a/nss/lib/ckfw/pem/prsa.c b/nss/lib/ckfw/pem/prsa.c
index f0e069c..101b6b3 100644
--- a/nss/lib/ckfw/pem/prsa.c
+++ b/nss/lib/ckfw/pem/prsa.c
@@ -171,9 +171,10 @@ pem_getPrivateKey(PLArenaPool *arena, SECItem *rawkey, CK_RV * pError, NSSItem *
     rv = SEC_ASN1DecodeItem(arena, pki, pem_PrivateKeyInfoTemplate, rawkey);
     if (rv != SECSuccess) {
         /* not PKCS#8 - assume it's a "raw" RSA private key */
+        plog("Failed to decode key, assuming raw RSA private key\n");
         keysrc = rawkey;
     } else if (SECOID_GetAlgorithmTag(&pki->algorithm) == SEC_OID_PKCS1_RSA_ENCRYPTION) {
-        keysrc = &pki->privateKey;        
+        keysrc = &pki->privateKey;
     } else { /* unsupported */
         *pError = CKR_FUNCTION_NOT_SUPPORTED;
         goto done;
@@ -211,21 +212,31 @@ pem_getPrivateKey(PLArenaPool *arena, SECItem *rawkey, CK_RV * pError, NSSItem *
                                 keysrc);
 
     if (rv != SECSuccess) {
-        goto done;
+        plog("SEC_QuickDERDecodeItem failed\n");
+        *pError = CKR_KEY_TYPE_INCONSISTENT;
+        return NULL;
     }
 
 done:
     return lpk;
 }
 
-void
+CK_RV
 pem_PopulateModulusExponent(pemInternalObject * io)
 {
-    const NSSItem *classItem = pem_FetchAttribute(io, CKA_CLASS);
-    const NSSItem *keyType = pem_FetchAttribute(io, CKA_KEY_TYPE);
+    CK_RV error = CKR_OK;
+    const NSSItem *classItem;
+    const NSSItem *keyType;
     pemLOWKEYPrivateKey *lpk = NULL;
     PLArenaPool *arena;
-    CK_RV pError = 0;
+
+    classItem = pem_FetchAttribute(io, CKA_CLASS, &error);
+    if (error != CKR_OK)
+        return error;
+
+    keyType = pem_FetchAttribute(io, CKA_KEY_TYPE, &error);
+    if (error != CKR_OK)
+        return error;
 
     /* make sure we have the right objects */
     if (((const NSSItem *) NULL == classItem) ||
@@ -234,18 +245,19 @@ pem_PopulateModulusExponent(pemInternalObject * io)
         ((const NSSItem *) NULL == keyType) ||
         (sizeof(CK_KEY_TYPE) != keyType->size) ||
         (CKK_RSA != *(CK_KEY_TYPE *) keyType->data)) {
-        return;
+        return CKR_KEY_TYPE_INCONSISTENT;
     }
 
     arena = PORT_NewArena(2048);
     if (!arena) {
-        return;
+        return CKR_HOST_MEMORY;
     }
 
-    lpk = pem_getPrivateKey(arena, io->u.key.key.privateKey, &pError, NULL);
+    lpk = pem_getPrivateKey(arena, io->u.key.key.privateKey, &error, NULL);
     if (lpk == NULL) {
+        plog("pem_PopulateModulusExponent: pem_getPrivateKey returned NULL, error 0x%08x\n", error);
         PORT_FreeArena(arena, PR_FALSE);
-        return;
+        return (error ? error : CKR_KEY_TYPE_INCONSISTENT);
     }
 
     nss_ZFreeIf(io->u.key.key.modulus.data);
@@ -308,7 +320,7 @@ pem_PopulateModulusExponent(pemInternalObject * io)
                    lpk->u.rsa.coefficient.len);
 
     pem_DestroyPrivateKey(lpk);
-    return;
+    return CKR_OK;
 }
 
 typedef struct pemInternalCryptoOperationRSAPrivStr
@@ -335,12 +347,20 @@ pem_mdCryptoOperationRSAPriv_Create
 )
 {
     pemInternalObject *iKey = (pemInternalObject *) mdKey->etc;
-    const NSSItem *classItem = pem_FetchAttribute(iKey, CKA_CLASS);
-    const NSSItem *keyType = pem_FetchAttribute(iKey, CKA_KEY_TYPE);
+    const NSSItem *classItem;
+    const NSSItem *keyType;
     pemInternalCryptoOperationRSAPriv *iOperation;
     pemLOWKEYPrivateKey *lpk = NULL;
     PLArenaPool *arena;
 
+    classItem = pem_FetchAttribute(iKey, CKA_CLASS, pError);
+    if (*pError != CKR_OK)
+        return (NSSCKMDCryptoOperation *) NULL;
+
+    keyType = pem_FetchAttribute(iKey, CKA_KEY_TYPE, pError);
+    if (*pError != CKR_OK)
+        return (NSSCKMDCryptoOperation *) NULL;
+
     /* make sure we have the right objects */
     if (((const NSSItem *) NULL == classItem) ||
         (sizeof(CK_OBJECT_CLASS) != classItem->size) ||
@@ -360,6 +380,7 @@ pem_mdCryptoOperationRSAPriv_Create
 
     lpk = pem_getPrivateKey(arena, iKey->u.key.key.privateKey, pError, &iKey->u.key.key.modulus);
     if (lpk == NULL) {
+        plog("pem_mdCryptoOperationRSAPriv_Create: pem_getPrivateKey returned NULL, pError 0x%08x\n", *pError);
         PORT_FreeArena(arena, PR_FALSE);
         return (NSSCKMDCryptoOperation *) NULL;
     }
@@ -418,7 +439,7 @@ pem_mdCryptoOperationRSA_GetFinalLength
     pemInternalCryptoOperationRSAPriv *iOperation =
         (pemInternalCryptoOperationRSAPriv *) mdOperation->etc;
     const NSSItem *modulus =
-        pem_FetchAttribute(iOperation->iKey, CKA_MODULUS);
+        pem_FetchAttribute(iOperation->iKey, CKA_MODULUS, pError);
 
     if (NULL == modulus) {
         *pError = CKR_FUNCTION_FAILED;
-- 
2.9.3


From 06ef155482b138d12d2a482b08cc1cbd0f82f47d Mon Sep 17 00:00:00 2001
From: Kamil Dudka <kdudka@redhat.com>
Date: Tue, 28 Feb 2017 16:55:15 +0100
Subject: [PATCH 2/3] pobject: fix use of uninitialized value

... while loading an invalid private key

Upstream-commit: e83bb4095557307c68567b00e9dd43dc1ecb84aa
Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 nss/lib/ckfw/pem/pobject.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/nss/lib/ckfw/pem/pobject.c b/nss/lib/ckfw/pem/pobject.c
index ea59c57..ac46c6f 100644
--- a/nss/lib/ckfw/pem/pobject.c
+++ b/nss/lib/ckfw/pem/pobject.c
@@ -1087,7 +1087,7 @@ pem_CreateObject
 #if 0
     pemToken *token;
 #endif
-    int cipher;
+    int cipher = 0;
     char *ivstring = NULL;
     pemInternalObject *listObj = NULL;
     pemObjectListItem *listItem = NULL;
-- 
2.9.3


From 68978e4c249cf58e81e3114ab6cf5b68883d371e Mon Sep 17 00:00:00 2001
From: Kamil Dudka <kdudka@redhat.com>
Date: Tue, 28 Feb 2017 16:57:16 +0100
Subject: [PATCH 3/3] psession: fix NULL dereference on invalid private keys

Upstream-commit: 6eba82481cef1bc367a98a9eabff794082712ae6
Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 nss/lib/ckfw/pem/psession.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/nss/lib/ckfw/pem/psession.c b/nss/lib/ckfw/pem/psession.c
index 70c5407..de9f455 100644
--- a/nss/lib/ckfw/pem/psession.c
+++ b/nss/lib/ckfw/pem/psession.c
@@ -262,6 +262,10 @@ pem_mdSession_Login
     }
 
     /* Convert the IV from hex into an array of bytes */
+    if (NULL == io->u.key.ivstring) {
+        rv = CKR_PIN_INCORRECT;
+        goto loser;
+    }
     iv = convert_iv(io->u.key.ivstring, 8);
 
     /* Convert the PIN and IV into a DES key */
-- 
2.9.3

